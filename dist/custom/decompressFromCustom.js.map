{"version":3,"file":"decompressFromCustom.js","sources":["../../src/custom/decompressFromCustom.ts"],"sourcesContent":["/*\n * SPDX-FileCopyrightText: 2013 Pieroxy <pieroxy@pieroxy.net>\n *\n * SPDX-License-Identifier: MIT\n */\n\nimport { decompress } from \"../raw/decompress\";\n\nexport function decompressFromCustom(compressed: string | null, dict: string): string | null {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    if (dict.length < 2) return null;\n\n    const charsPerUnicodeChar: number = Math.ceil(Math.log(65536) / Math.log(dict.length));\n\n    if (compressed.length % charsPerUnicodeChar != 0) return null;\n\n    let res: string = \"\";\n    let current_value;\n    let index;\n\n    for (let i = 0, TotalLen = compressed.length; i < TotalLen; i = i + charsPerUnicodeChar) {\n        current_value = 0;\n\n        for (let j = 0; j < charsPerUnicodeChar; j++) {\n            index = dict.indexOf(compressed[i + j]);\n            current_value = current_value + index * Math.pow(dict.length, charsPerUnicodeChar - 1 - j);\n        }\n\n        res = res + String.fromCharCode(current_value);\n    }\n\n    return decompress(res);\n}\n"],"names":["decompressFromCustom","compressed","dict","charsPerUnicodeChar","res","current_value","index","i","TotalLen","j","decompress"],"mappings":";AAQgB,SAAAA,EAAqBC,GAA2BC,GAA6B;AACzF,MAAID,KAAc;AAAa,WAAA;AAE/B,MADIA,KAAc,MACdC,EAAK,SAAS;AAAU,WAAA;AAEtB,QAAAC,IAA8B,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAID,EAAK,MAAM,CAAC;AAEjF,MAAAD,EAAW,SAASE,KAAuB;AAAU,WAAA;AAEzD,MAAIC,IAAc,IACdC,GACAC;AAEK,WAAAC,IAAI,GAAGC,IAAWP,EAAW,QAAQM,IAAIC,GAAUD,IAAIA,IAAIJ,GAAqB;AACrE,IAAAE,IAAA;AAEhB,aAASI,IAAI,GAAGA,IAAIN,GAAqBM;AACrC,MAAAH,IAAQJ,EAAK,QAAQD,EAAWM,IAAIE,CAAC,CAAC,GACtBJ,IAAAA,IAAgBC,IAAQ,KAAK,IAAIJ,EAAK,QAAQC,IAAsB,IAAIM,CAAC;AAGvF,IAAAL,IAAAA,IAAM,OAAO,aAAaC,CAAa;AAAA,EACjD;AAEA,SAAOK,EAAWN,CAAG;AACzB;"}